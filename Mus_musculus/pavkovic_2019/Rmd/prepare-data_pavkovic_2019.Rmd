---
title: "DU-Bii Study cases - Mouse fibrotic kidney"
author: "Olivier Sand and Jacques van Helden"
date: '`r Sys.Date()`'
output:
  slidy_presentation:
    smart: no
    slide_level: 2
    self_contained: yes
    fig_caption: yes
    fig_height: 6
    fig_width: 7
    highlight: tango
    incremental: no
    keep_md: yes
    smaller: yes
    theme: cerulean
    toc: yes
    widescreen: yes
  html_document:
    self_contained: no
    fig_caption: yes
    highlight: zenburn
    theme: cerulean
    toc: yes
    toc_depth: 3
    toc_float: yes
    code_folding: "hide"
  ioslides_presentation:
    slide_level: 2
    self_contained: no
    colortheme: dolphin
    fig_caption: yes
    fig_height: 6
    fig_width: 7
    fonttheme: structurebold
    highlight: tango
    smaller: yes
    toc: yes
    widescreen: yes
  revealjs::revealjs_presentation:
    theme: night
    transition: none
    self_contained: true
    css: ../slides.css
  pdf_document:
    fig_caption: yes
    highlight: zenburn
    toc: yes
    toc_depth: 3
  beamer_presentation:
    colortheme: dolphin
    fig_caption: yes
    fig_height: 6
    fig_width: 7
    fonttheme: structurebold
    highlight: tango
    incremental: no
    keep_tex: no
    slide_level: 2
    theme: Montpellier
    toc: yes
font-import: http://fonts.googleapis.com/css?family=Risque
subtitle: DUBii 2020
font-family: Garamond
transition: linear
editor_options: 
  chunk_output_type: console
---


```{r libraries, include=FALSE, echo=FALSE, eval=TRUE}

requiredLib <- c("knitr", "stringr")
for (lib in requiredLib) {
  if (!require(lib, character.only = TRUE)) {
    install.packages(lib, )
  }
  require(lib, character.only = TRUE)
}

```



```{r settings, include=FALSE, echo=FALSE, eval=TRUE}

options(width = 300)
# options(encoding = 'UTF-8')
knitr::opts_chunk$set(
  fig.width = 7, fig.height = 5, 
  fig.path = 'figures/mouse-kidney_',
  fig.align = "center", 
  size = "tiny", 
  echo = TRUE, 
  eval = TRUE, 
  warning = FALSE, 
  message = FALSE, 
  results = TRUE, 
  comment = "")

options(scipen = 12) ## Max number of digits for non-scientific notation
# knitr::asis_output("\\footnotesize")

```


## Reference


Pavkovic, M., Pantano, L., Gerlach, C.V. et al. Multi omics analysis of fibrotic kidneys in two mouse models. Sci Data 6, 92 (2019). 

- <https://doi.org/10.1038/s41597-019-0095-5> 
- <https://www.nature.com/articles/s41597-019-0095-5#citeas>
- Mouse fibrotic kidney browser: <http://hbcreports.med.harvard.edu/fmm/>
- Data on Zenodo: <https://zenodo.org/record/2592516>


## Data sources

| Doc | URL | 
|:-----------------------------|:--------------------------|
| Total RNA for the experiment on Unilateral ureter obstruction (UUO) model | <https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE118339> |



## Parameters

```{r parameters}
#### Define parameters for the analysis ####

## Keep a trace of the original parameters
par.ori <- par(no.readonly = TRUE)

## Analysis parameters
parameters <- list(
  epsilon = 0.1,
  minCount = 10,
  forceDownload = FALSE)

kable(as.data.frame(parameters))

```

## Output directories

```{r outdirs}
#### Output directories ####
outdirs <- list()
outdirs$main <- getwd()

## Data directory, where the data will be downloaded and uncompressed
outdirs$data <- file.path(outdirs$main, "data")
dir.create(outdirs$data, recursive = TRUE, showWarnings = FALSE)

## Main result directory
outdirs$results <- file.path(outdirs$main, "results")

# Transcriptome results
outdirs$transcriptome <- file.path(outdirs$main, "results/transcriptome")
dir.create(outdirs$transcriptome, recursive = TRUE, showWarnings = FALSE)
```



## Download transcriptome data


```{r download_transcriptome}
#### Download transcriptome data ####
archiveFile <- "MouseKidneyFibrOmics-v1.0.zip"
archiveURL <- file.path("https://zenodo.org/record/2592516/files/hbc", archiveFile)
localDataArchive <- file.path(outdirs$data, archiveFile)

if (file.exists(localDataArchive) & !parameters$forceDownload) {
  message("Data archive already downloaded:\n\t", localDataArchive)
} else {
  message("Downloading data archive from zenodo: ", archiveURL)
  download.file(url = archiveURL, destfile =  localDataArchive)
  
  ## Uncompess the archive
  message("Uncompressing data archive")
  unzip(zipfile = localDataArchive, exdir = outdirs$data)
}

## Define destination directory
# outdirs$csv <- file.path(outdirs$data, "CSV")
# dir.create(outdirs$csv, showWarnings = FALSE, recursive = TRUE)


```

## Load raw counts

```{r load_raw_counts}
#### Load raw counts data table ####
rawCountFile <- file.path(
  outdirs$data,
  "hbc-MouseKidneyFibrOmics-a39e55a/tables/uuo/results/counts/raw_counts.csv.gz")
rawCounts <- read.csv(file = rawCountFile, header = 1, row.names = 1)

```

The RNA-seq trnascriptome data was loaded as raw counts. This table contains `r nrow(rawCounts)` rows (genes) and `r ncol(rawCounts)` columns (samples).  


## Build metadata table

```{r metadata}
#### Build metadata table ####
metadata <- data.frame(sampleName = colnames(rawCounts))
metadata[ , c("condition", "sampleNumber")] <- 
  str_split_fixed(string = metadata$sampleName, pattern = "_", n = 2)

## Colors per condition
colPerCondition <- c(normal = "#BBFFBB",
                     day3 = "#FFFFDD", 
                     day7 = "#FFDD88",
                     day14 = "#FF4400")
metadata$color <- colPerCondition[metadata$condition]
```


## Distribution of raw counts

```{r RNA-seq_count_distrib, fig.width=12, fig.height=5, out.width="70%", fig.cap="Distribution of raw counts"}
hist(unlist(rawCounts), breaks = 1000, 
     main = "Raw count distribution", 
     xlab = "Raw counts", 
     ylab = "Number of genes (all samples)")
```

The distribution of raw counts is not very informative, because the range is defined by some outlier, i.e. a gene having a huge number of reads. Even with  strong zoom on the abcsissa range from 0 to 500, the histogram shows a steep drop in the first bins. 

## Distribution of raw counts - truncated abscissa

```{r RNA-seq_count_distrib_truncated, fig.width=12, fig.height=5, out.width="70%", fig.cap="Distribution of raw counts"}
#### Count distrib - truncated abscissa ####
hist(unlist(rawCounts), breaks = 500000, 
     main = "Raw count distribution", 
     xlab = "Raw counts (truncated abscissa", 
     ylab = "Number of genes (all samples)",
     xlim = c(0, 500))

```

## Log2-transformed counts

A typical approach is to normalise the counts by applying a log2 transformation .
This however creates a problem when the counts of a given gene in a given sample is 0. To circumvent this, we can add an epsilon ($\epsilon = `r parameters$epsilon`$) before the log2 transformation. 

```{r log2_counts, fig.width=12, fig.height=5, out.width="70%"}

#### Log2 transformatiojn of the counts ####
log2Counts <- log2(rawCounts + parameters$epsilon)
hist(unlist(log2Counts), breaks = seq(from = -5, to = 22, by = 0.1),
     main = "log2-counts distribution",
     xlab = "log2(Counts + epsilon)", 
     ylab = "Number of genes", col = "#BBFFBB")

```


## Box plots

We can now inspect the distribution of counts per sample with the `boxplot()` function.

```{r box plots, fig.width=5, fig.height=7, out.width="25%"}
#### Box plots ####
par(mar = c(4, 6, 5, 1))
boxplot(log2Counts, 
        col = metadata$color,
        horizontal = TRUE, 
        las = 1, 
        main = "log2-transformed", 
        xlab = "log2(counts)")
par(par.ori)
```

## Box plot comment

We notice an obvious problem: the vast majority of counts is very small. This can result from different causes, which will not be investigated in this context. 

## Gene filtering

```{r gene_filtering, fig.width=5, fig.height=7, out.width="50%"}

## Filter out the genes with very low counts in all conditions
undetectedGenes <- apply(rawCounts, MARGIN = 1, FUN = sum) < parameters$minCount
# table(undetectedGenes)
log2CountsFiltered <- log2Counts[!undetectedGenes, ]

```

We filtered out all the genes whose maximal count value across all samples was lower than `r parameters$minCount`. Among the `r nrow(rawCounts)` genes from the raw count table, `r sum(undetectedGenes)` were considered undetected according to this criterion. We use the remaining `r nrow(log2CountsFiltered)` genes for the subsequent analyses. 

## Gene filtered boxplot

```{r boxplot_filtered, fig.width=5, fig.height=7, out.width="32%"}
#### Box plots after filtering ####
par(mar = c(4, 6, 5, 1))
boxplot(log2CountsFiltered, 
        col = metadata$color,
        horizontal = TRUE, 
        las = 1,
        main = "Filtered genes", 
        xlab = "log2(counts)")
par(par.ori)

```

## Normalisation (more precisely: scaling)

Before going any further, it is important to ensure some normalisation of the counts, in order to correct for biases due to inter-sample differences in sequencing depth. 

For the sake of simplicity, we will use here a very simple criterion: median-based normalisation. The principle is to multiply the counts of each sample by a scaling factor in order to bring each sample to the same median count. 

## Normalisation code

```{r median_normalisation, fig.width=5, fig.height=7, out.width="25%"}

#### Median-based normalisation ####
sampleMedians <- apply(log2CountsFiltered, 2, median)
seriesMedian <- median(sampleMedians)
scalingFactors <- seriesMedian / sampleMedians

log2CountsStandardised <- data.frame(matrix(
  nrow = nrow(log2CountsFiltered),
  ncol = ncol(log2CountsFiltered)))
colnames(log2CountsStandardised) <- colnames(log2CountsFiltered)
rownames(log2CountsStandardised) <- rownames(log2CountsFiltered)
for (j in 1:ncol(log2CountsFiltered)) {
  log2CountsStandardised[, j] <- log2CountsFiltered[, j] * scalingFactors[j]
}

## Check the remaining medians
apply(log2CountsStandardised, 2, median)

```

## Normalization boxplot

```{r median_normalisation_boxplot, fig.width=5, fig.height=7, out.width="32%"}
#### Box plots after scaling ####
par(mar = c(4, 6, 5, 1))
boxplot(log2CountsStandardised, 
        col = metadata$color,
        horizontal = TRUE, 
        las = 1,
        main = "Median-based scaled", 
        xlab = "log2(counts")
par(par.ori)


```




## Session info

```{r session_info}

sessionInfo()
```

